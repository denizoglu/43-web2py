## Giriş
web2py``web2py``:cite  veritabanlarına dayanan güvenli web programlarının hızlı yazılım geliştirme metoduyla yazılmasında kullanılabilecek ücretsiz, açık-kaynaklı bir web programlama çatısıdır (framework);  Python``python``:cite 'da yazılmış ve Python'da programlanabilmektedir. 

web2py tam teşekküllü bir web çatısıdır; bunun anlamı, herşeyiyle kullanışlı ve çalışan web uygulamaları geliştirebilmeniz için ihtiyaç duyacağınız tüm bileşenleri içermektedir.

web2py Model-Görünüm-Kontrol tasarım anlayışı gibi (Model-View-Controller - MVC) iyi yazılım mühendisliği uygulamalarını takip etmek isteyen web geliştiricilere yardımcı olacak şekilde tasarlanmıştır. web2py verinin ham halini ve teknik biçimini(Model) verinin sunulması (Görünüm) ile uygulama mantığı ve bilgi/iş akışından (Kontrol) ayrı tutmaktadır. Bunu gerçekleştirmek için web2py geliştiricinin bu üç parçadan her birini ayrı ayrı tasarlayabileceği, uygulayabileceği ve test edebileceği, en son olarak da hepsini biraraya getirip çalıştırabileceği kütüphaneleri de sunmaktadır. 

web2py güvenlik için yapılmıştır. Bu, web2py'ın temelleri oturmuş uygulamaların yaptığı şekilde, güvenlik açığı oluşturabilecek birçok sorunu kendiliğinden hallettiği anlamına gelmektedir. Örneğin, (girdilere kod yerleştirme saldırılarına karşı) tüm girdileri doğrular, (sitelerarası betiklere ("cross-site scripting") karşı) tüm çıktıyı yeniden biçimlendirir, (dizin tarama temelli saldırılara karşı) dosyaları yeniden adlandırır. web2py, uygulama geliştiricilerin güvenlik açığı oluşturma ihtimallerini azaltarak onlara uğraşacakları daha az iş bırakmaktadır. 

web2py, içerisinde bulunan ve dinamik şekilde SQL``sql-w``:cite sorguları yazan Veritabanı Soyutlama Katmanı - VSK (Database Abstraction Layer - DAL) sayesinde sizin, yani geliştiricinin SQL sorgusu yazmasına gerek bırakmamaktadır. VSK (DAL) hangi veritabanı için nasıl SQL sorgu üreteceğini bilmektedir. SQLite``sqlite``:cite, MySQL``mysql``:cite, PostgreSQL``postgres``:cite, MSSQL``mssql``:cite,
FireBird``firebird``:cite, Oracle``oracle``:cite, IBM DB2``db2``:cite, Informix``informix``:cite ve  Ingres``ingresdb``:cite gibi veritabanları dışında; DAL (VSK), Google App Engine (GAE)``gae``:cite üzerinde çalışıyorsa Google Datastore için de fonksiyonlar ve sorgular üretebilmektedir. .

Şu an deneme aşamasında olan daha fazla sayıda veritabanını da desteklemekteyiz. Daha güncel uyumlandırmalar(adapter) ve uygulamalar listesi için lütfen posta listelerini ve web2py web sitesine bakınız. Bir veya daha fazla veritabanı tablosu tanımlanır tanımlanmaz web2py da veritabanına ve tablolardaki bilgilere erişebilmek için gerekli olan tam teşekküllü bir web tabanlı veritabanı yönetim arayüzünü üretir. 

web2py'ı diğer çatılardan ayıran şey, web'in kendinin bilgisayar olduğunu kabul etmiş olan Web2.0 paradigmasını tam olarak içselleştiren tek çatı olmasıdır. Hatta, web2py herhangi bir kurulum ve konfigürasyona ihtiyaç duymayıp Python çalıştırabilen herhangi bir mimari üzerinde (Windows, Windows CE, Mac OS X, iOS ve Unix/Linux) çalışabilmekte ve, geliştirme, uygulamaya geçme, bakım aşamaları gibi safhaların hepsi yerel olarak çatının kurulduğu bilgisayardan veya uzaktan bir web arayüzü ile gerçekleştirilebilmektedir. web2py, uygulamaların geriye dönük uyumluluğunu sağlayabilmek adına "resmi olarak" sadece 2.5 sürümünü destekliyor görünse de, aslında CPython ve JPython yerleştirmeleri ile uyumlu ve Python'un 2.4, 2.5, 2.6 ve 2.7 sürümleri üzerinde çalışabilmektedir. 

web2py fişleme (ticketing) sistemi de sunmaktadır. Bir hata oluşması durumunda, kullanıcıya hata için düzenlenen bir fiş sunulurken yöneticinin ilgisi için de kütüğe kaydedilir.

web2py açık kaynaklı bir yazılımdır ve LGPL sürüm 3 lisansıyla sunulmaktadır.

web2py'ın bir diğer önemli özelliği de, web2py geliştiricileri olarak bizim geriye yönelik uyumluluk sunma konusuna önem vermemiz. Şimdiye dek, 2007'de web2py'ın ilk sürümünden bu yana bu böyle oldu. Şu ana kadar web2py'a yeni çok özellikler eklendi ve hatalar giderildi, ancak bir program web2py 1.0 sürümü ile çalışıyorduysa, aynı program bugün hala -belki de daha iyi şekilde- çalışıyor olacaktır. 

İşte size web2py'ın gücü yanında sadeliğini gösteren birkaç örnek: Mesela bu 
``
db.define_table('kisiler', Field('isim'), Field('resim', 'upload'))
``:code

tek satırlık kod "isim" adlı normal yazı tipinde bir alan ile "resim"  adlı bir yüklenmesi beklenen ve gereken bir gerçek resim dosyası alanını içeren "kisiler" adında bir veritabanı tablosu oluşturur. Eğer böyle bir veritabanı halihazırda mevcut ise ve fakat bu tanıma uymuyorsa, uygun bir şekilde değiştirilir. 

Yukarıdaki veritabanı tablosu oluşturuldu farzedersek, 
``
form = SQLFORM(db.kisiler).process()
``:code

kodu bu tabloya resimlerin eklenebilmesini sağlayan bir girdi formu oluşturur. Bu kod aynı zamanda formda doldurulmuş olan alanların geçerliliğini doğrular, yüklenen resim dosyasının adını güvenli bir şekilde değiştirir, resim dosyasını kaydeder, veritabanına ilgili kaydı (herhangi bir çift giriş olmamasını sağlayarak) ekler, ve en son olarak kullanıcı tarafından gösterilen girdinin geçerli olmaması durumunda formun kendisini güncelleyerek bir hata mesajı eklenmesini sağlar.

This code embeds a fully working wiki with tags, search, tag cloud, permissions, media attachments, and oembed support:

``
def index(): return auth.wiki()
``

Öte yandan bu kod;
``
@auth.requires_permission('read','kisiler')
def f(): ....
``:code

kayıtlı olmayan ve "kisiler" veritabanı tablosundaki kayıtlardan "read" izni olmayan bir gruptaki misafir kullanıcıların ``f`` fonksiyonuna erişimini engeller. Eğer ziyaretçi sisteme giriş yapmamışsa, bir giriş sayfasına yönlendirilir (web2py bunu öntanımlı olarak sağlar).

web2py, bileşenler, yani bir sayfanın görünümünün içinde yüklenerek o sayfayı yeniden yüklemenize gerek bırakmaksızın Ajax vasıtasıyla ziyaretçi ile etkileşimde bulunmasına izin veren işlemlari de kullanmanıza izin verir. Bu, uygulamaları iyice modüler şekilde dizayn edebilmenize imkan veren ``LOAD`` yardımcısı kullanılarak yapılır, bu yardımcı daha sonra 3. Bölüm'de wiki bağlamında ve en son daha da detaylı olarak kitabın son bölümünde incelenecektir.   

Kitabımızın bu 6. Baskısı ``web2py`` 2.4.1 ve daha sonraki sürümleri anlatmaktadır. 

### İlkeler

Python'da programlama tipik olarak şu ilkeleri takip etmektedir:
- Kendini Tekrar Etme! (DRY - Don't Repeat Yourself)
- Birşeyi yapmanın tek bir yolu olmalıdır
- Açık ve doğrudan olan, örtülü ve dolaylı olandan daha iyidir.

web2py ilk iki ilkeyi tamamen kabul ederek programcıyı kod tekrarını men eden oturmuş sağlam yazılım mühendisliği uygulamalarını takip etmeleri yönünde teşvik eder. web2py ayrıca geliştiricilere web uygulama geliştirmede artık standart haline gelmiş işlerde (formlar oluşturmak ve onları işlemek, oturumları yönetmek, çerezler, hatalar vs.) yol göstermektedir. 

``request``:inxx
web2py diğer çatılardan üçüncü bir açıdan da ayrılmaktadır, ki bu bazen ilk ikisiyle çelişebilir. Temelde, web2py kullanıcı uygulamalarını içe aktarmaz, onun yerine önceden tanımlanmış bir ortam içinde çalıştırır. Bu ortamda Python komutları ve anahtar kelimeleri ve web2py'ın anahtar kelimeleri bulunmaktadır. 

Bu, bazılarına sihir gibi görünebilir, ancak değildir ve öyle de görülemelidir. Sadece, pratikte, bazı bileşenler/modüller sizin yapmanıza gerek kalmadan çağrılırlar. web2py bu şekilde diğer bazı çatıların sahip olduğu tipik sıkıcı özellik olan 'her model ve kontrolün başında hep aynı modülleri çağırma' dan kaçınmaya çalışmaktadır.

web2py kendi modüllerini çağırarak hem zaman kazanmakta hem de hataları önlemektedir. Böylece Python'un "Kendini Tekrar Etme!" ve "Birşeyi yapmanın tek bir yolu olmalıdır" felsefelerine uymaktadır. 

Eğer geliştirici başka Python modülleri veya 3. taraf yazılımlarını kullanmak isterse, bu modüller tıpkı diğer Python programlarında olduğu gibi ayrıca çağrılmalıdırlar.

### Web Çatıları
``PHP``:inxx ``ASP``:inxx ``JSP``:inxx

En temelde, bir web uygulaması bir URL ziyaret edildiğinde çalıştırılan programlar (veya fonksiyonlar) kümesidir denilebilir. Program(lar)ın çıktısı ziyaretçiye geri verilir ve tarayıcı da bunu görünümle giydirerek ziyaretçiye sayfanın son halini gösterir.

Web uygulama çatılarının amacı geliştiricilerin uygulamalarını hızlı, kolayca ve hatasızca üretebilmelerini sağlamaktır. Bu da API'lar (Application Protocol Interface - Uygulama Protokol Arayüzü) ve gerekli kodun yazılmasını kolaylaştıran ve hızlandıran araçlarla olur. 

Web uygulamaları geliştirirken izlenen iki klasik yaklaşım şunlardır:
- HTML'i programlar aracılığıyla üretmek
- HTML sayfalarının içine yazılan kodu gömmek

Bunlardan ilki, ilk CGI betiklerinin takip ettiği sistemdi. İkinci yaklaşım ise C'ye benzer bir dil olan PHP``php``:cite (kod PHP dilindedir), Visual Basic dilinde yazılmış olan ASP ve kodu Java'da yazılan JSP gibi örneklerini verebileceğimiz uygulamalar tarafından benimsenmiştir.

İsterseniz bunu örneklerde görelim. Aşağıdaki PHP kodu çalıştırıldığında size bir veritabanından verileri alır, bunların arasından seçilen bazılarını gösterecek bir HTML sayfası üretir:
``
<html><body><h1>Records</h1><?
  mysql_connect(localhost,username,password);
  @mysql_select_db(database) or die( "Veritabanina baglanamadi!");
  $sorgu="SELECT * FROM kisiler";
  $sonuc=mysql_query($sorgu);
  mysql_close();
  $i=0;
  while ($i < mysql_numrows($sonuc)) {
    $isim=mysql_result($sonuc,$i,"isim");
    $telefon=mysql_result($sonuc,$i,"telefon");
    echo "<b>$isim</b><br>Telefon:$telefon<br /><br /><hr /><br />";
    $i++;
  }
?></body></html>
``:code

Bu yaklaşımın problemi php kodunun HTML'in içine gömülmesi gerekliliğidir. Dahası, aynı kodun daha fazla HTML kodu üretmesi ve veritabanı sorguları için farklı SQL ifadeleri oluşturması gerekmekte, bunlar da uygulamanın birbirine dolanmış, okunması ve bakımı çok daha zorlaşmış birçok katmandan oluşması anlamına gelmektedir. Ajax uygulamaları içinse durum çok daha vahimdir ve olayın karmaşıklığı uygulamayı oluşturan sayfaların (ve dosyaların) sayısıyla doğru orantılı olarak kötüleşmektedir. 

Buna karşın, yukarıdaki örnek kodla yapılan iş web2py'da sadece 2 satırlık Python kodu ile şöyle yapılabilmektedir:
``
def index():
	return HTML(BODY(H1('Kayitlar'), db().select(db.kisiler.ALL)))
``:code

Bu basit örnekte, HTML sayfası programda ``HTML``, ``BODY`` ve ``H1`` nesneleriyle tanımlanmakta ve gösterilmekte, ``db`` isimli veritabanından ``select`` ile SQL sorgusu oluşturulmakta ve en son olarak üretilen herşey HTML'e dönüştürülmektedir. Burada dikkatinizi çekmek istediğim birşey var; ``db`` Python'un komutlarından biri değil, kullanıcının tanımlamış olduğu ve veritabanı ifade eden bir değişken sadece. Ancak, karmaşıklığı önlemek adına bu değişkeni veritabanı bağlantısını ifade etmek için bundan sonra bir cins isim olarak, herhangi bir veritabanı bağlantısını ifade etmek için kullanacağız.

Web uygulama çatıları genellikle iki ana grupta toplanı: "Yapıştırılmış" çatılar (İng. 'glued' frameworks) farklı birkaç veya daha fazla üçüncü taraf 'bileşen'lerin biraraya getirilerek ve 'yapıştırılarak' (ing. gluing together) birleştirilmesiyle oluşturulur. "Tam teşekküllü" çatılar (ing. full stack frameworks) ise özellike birlikte çalışmak üzere tasarlanmış ve birbirleriyle tam entegre olan bileşenlerden oluşmaktadır.

web2py muntazam bir "tam teşekküllü uygulama çatısı"dır. Hemen tüm bileşenleri birbirleriyle çalışmak üzere yazılmıştır, ancak yine de birçoğu web2py'ın dışında da çalışabilmektedirler. Örneğin Veritabanı Soyutlaştırma Katmanını - DAL (İng. DAL - Database Abstraction Layer) veya şablon dilini web2py'dan bağımsız olarak kendi Python uygulamalarınızda ``import gluon.dal`` veya ``import gluon.template`` şeklinde programınızda içe aktararak (import) kullanabilirsiniz. ``gluon``, web2py'ın sistem kütüphanelerini içeren temel bileşenidir. Ancak veritabanı tablolarından bilgi çekerek formlar oluşturan ve bu formları işleyen bazı web2py modülleri web2py'ın diğer kendine has kütüphanelerine bağımlı oldukları için kendi başlarına (web2py'ın dışında) çalışmayabilirler. Öte yandan web2py örneğin diğer şablon dilleri ve DAL'ler gibi diğer üçüncü-taraf Python yazılımlarıyla da çalışabilmektedir, ancak bu üçüncü-taraf bileşenler web2py'ın asıl kendi bileşenleri kadar entegre olmayacaklardır. 

--------
Çevirmenin Notu: Bu kitapta bu noktadan itibaren 'Database Abstraction Layer' için İng. orjinalindeki 'DAL' kısaltmasını kullanacağım, zira DAL aynı zamanda modülün adı, böylece çevirinin kullanımında koda bakarken terimin Türkçe karşılığının kısaltması olan 'VSK'ın neye karşılık geldiğini sürekli hatırlamak zorunda kalınmayacağını ümit ediyorum.
--------

### Model-Görünüm-Kontrolör
``Model-View-Controller``:inxx
web2py, geliştiricilerin şunları birbirlerinden ayırmalarını sağlamaya çalışır: Verinin temsili (Model), sunumu (Görünüm) ve uygulamanın iş akışı/mantıksal yönergeleri (Kontrolör). Biraz önceki örneği tekrar ele alalım ve bunu web2py'da bir uygulama olarak nasıl geliştirebileceğimize bakalım. İşte bir MVC düzenleme arayüzü:

[[image @///image/en0.png center 480px]]

Tipik bir iş akışı web2py'a gelen bir istemde (request) aşağıdaki gibidir:

[[image @///image/en100.png center 480px]]

In the diagram:
- 'Sunucu' web2py'ın kendi bütünleşik sunucusu olabileceği gibi 3.taraf bir sunucu yazılıı da olabilir, örneğin Apache gibi. Çoklu süreçlendirmeyi (multi-threading) sunucu üstlenir. 
- "main" ana WSGI uygulamasıdır. Tüs rutin işleri yapar ve kullanıcı uygulaamarını idare eder. Çerezler, oturumlar, aktarımlar, URL yönlendirmeleri, geri bildirimler ve başlangıç ile ilgilenir. Eğer sunucu halihazırda zaten ilgilenmiyorsa sabit (statik) dosyaları da sunabilir veya akışa (stream) verebilir.
- Modeller, Görünümler ve Kontrol bileşenleri hep birlikte kullanıcı uygulamalarını oluşturmaktadır.
- Birden fazla uygulama aynı web2py oturumunda çalıştırılabilir. 
- Aralıklı çizgiler veritaban(lar)ıyla iletişim(ler)i simgelemektedir. Veritabanları ve bunların kullanımı temel SQL komutlarıyla yazılabildiği gibi (ki bunu çok önermiyoruz), daha çok tavsiye ettiğimiz şekilde web2py'ın DAL'ı (Database Abstraction Layer) ile de yapılabilir. DAL ile veritabanı sorguları yazarak kullandığımız veritabanı programından bağımsız olarak aynı komutlarla farklı veritabanlarından sorgu üretebilirsiniz, bu sayede veritabanı programını değiştiresniz de DAL ile yazılmış sorgu kodunu değiştirmeniz gerekmez. 
- Uygulama başlatıcı (dispatcher) istenen URL adresini kontrolördeki ilgili fonksiyona iletir. Bu fonksiyonun çıktısı bir yazı dizimi veya semboller sözlüğü ('hash' table) olabilir. Sözlükteki veri Görünüm bileşeni tarafından sunuma hazırlanarak giydirilir (render). Eğer (öntanımlı şekilde) ziyaretçi bir HTML sayfası istemişse, sözlük şeklindeki veri bir HTML sayfası olarak sunulur. Eğer XML şeklinde istenmişse, web2py bu sözlüğü XML'e dönüştürebileceği bir Görünüm bulmaya çalışacaktır. Geliştirici, veri modelini istediği şekilde sunabilmek için halihazırda desteklediğimiz protokollerden (HTML, XML, JSON, RSS, CSV, RTF) herhangi birini veya başka bir protokolü kullanabilir. 
- Tüm istemler bir aktarım işlemi (transaction) sırasına alınır ve herhangi bir istisna (exception) oluşması durumuda aktarım işlemini geri alır. Eğer istem başarılı olmuşsa aktarım da hayata geçirilir. 
- web2py oturumları ve oturum çerezlerini de otomatik olarak ele almakta, ve bir aktarım işlemi gerçekleştirildiğinde oturum da -aksi belirtilmemişse- otomatik olarak keydedilmektedir.
- Tekrar tekrar yapılması gereken rutin işleri (cron ile) belirli bir iş takvimine bağlamak ve yapılacak mutad işleri belli zamanlarda ve/ya belirli olayların gerçekleşmesi şartına bağlayarak çalıştırmak web2py ile mümkündür. Bu şekilde uzun ve işlemci zamanı alacak görevleri (örneğin testler) sunucunun ve/ya uygulamanın görece rahat olduğu zamanlarda arka planda çalıştırıp kullanıcının sayfadaki gezintisini yavaşlatmamak mümkün olmaktadır. 

Şimdi sadece üç dosyadan oluşan küçük ve fakat tastamam bir MVC uygulamasına göz atalım:

**"db.py" dosyası, Model'dir:**

``
db = DAL('sqlite://storage.sqlite')
db.define_table('kisi',
   Field('isim'),
   Field('telefon'))
``:code

Bu dosyadaki kod bir vtna bağlanarak (bu örneğimizde storage.sqlite dosyasında saklanan bir SQLite vt) ``kisi`` adlı bir tablo oluşturmakta. Eğer tablo mevcut değilse web2py onu oluştururu ve açık bir şekilde arka planda ne olduğunu göstererek kullanılan özel vt sistemine uygun bir biçimde SQL komutunu oluşturur. Uygulama geliştirici, üretilen SQL kodunu görebilmektedir. Ancak öntanımlı olarak SQLite seçili olsa da, vt olarak MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Informix, Interbase, Ingres ve Google App Engine gibi (hem SQL hem de NoSQL) geniş bir vt sistemleri listesinden herhangi birini seçip sistemini değiştirmesi durumunda bu ``kisi`` tablosunu oluşturmak için kodu değiştirmesine gerek duymamaktadır. 

Tablo tanımlanıp oluşturulduktan sonra web2py vtna ve tablolara erişim için **appadmin** adlı, vtyla alakalı tüm işlemlerin yapılabildiği web tabanlı bir vt yönetim arayüzü oluşturur. 

**"default.py" Kontrolör'dür:**

``
def kisiler():
    grid=SQLFORM.grid(db.kisi, user_signature=False)
    return locals()
``:code

web2py'da URL'ler Python modülleri ve fonksiyonlara eşlenirler (map). Yani her bir URL adres satırı bir Python modeli veya fonksiyonunun çalıştırılmasına eşlenmektedir. Yukarıdaki örnekte, kontrol modülü olan default.py dosyasında tek bir fonksiyon (veya "işlem") vardır: ``contacts``. Bir işlem, çıktı olarak bir karakter dizisi (string) -ki bu durumda isteme cevap olarak verilen bir HTML web sayfası- veya Python sözlüğü (anahtar:değer şeklinde ikililerden oluşan küme), veya da bu örnekte olduğu gibi bir dizi yerel değişken geri verebilir (return). Eğer fonksiyon bir sözlük geri vermişse, bu sözlük de kontrolör ile aynı ada sahip görünüme aktarılır, ve bu görünüm dosyası/kodu da sayfayı son görünümüne kavuşturur. Bu örnekte, ``contacts`` fonksiyonu/kontrolörü ``db.kisi`` tablosu için bir Seç/Ara/Oluştur/Güncelle/Sil listesi üretir ve bu listeyi görünüme iletir. 

**"default/kisi.html" Görünüm'dür:**

``
{{extend 'layout.html'}}
<h1>Kişilerimi Düzenle</h1>
{{=grid}}
``:code

Bu görünüm, ilgili kontrolör fonksiyonu (işlem) çalıştırıldıktan sonra web2py tarafından otomatik olarak çağrılır. Bu görünümün amacı işlemin çıktı olarak geri döndürdüğü sözlüğün (bizim durumumuzda ``grid``) HTML olarak sunulmasıdır. 

Görünüm dosyası HTML olarak yazılır, fakat HTML kodunun içine özel ``{{`` ve ``}}`` karakterleri içine alınmış Python kodu iliştirilir. Bu, yukarıdaki PHP kodundan farklıdır, zira burada HTML dosyası içine iliştirilen tek kod "sunum katmanı" kodudur. Görünümün en başında atıf yapılan "layout.html" dosyası  web2py'la birlikte gelir ve tüm web2py uygulamaları için temel bir görünüm şablonu sunar. Bu şablon "layout.html" dosyası yine istenilen şekilde düzeltilebilir veya başkasıyla değiştirilebilir. 

### Neden web2py?

w2p birçok web uygulama çatılarından birisi, ancak saygı uyandıran ve kendine münhasır vasıfları bulunmaktadır. web2py aslen bir eğitim aracı olarak geliştirilmiş olup şunlar öncelikli amaç olarak gözönünde bulundurulmuştur:
- Fonksiyonellikten ödün vermeden kullanıcıların sunucu tarafında web geliştirmeyi kolayca öğrenebilmeleri. Bunun için, web2py herhangi bir kurulum veya yapılandırma gerektirmemekte, herhangi bir ön koşul program istememekte (Python 2.5 ve onun standart kütüphanelerine ihtiyaç duyan daoğrudan kaynak kodunun paylaşıldığı dağıtım hariç), ve kendi içinde bir Debugger ve veritabanı arayüzü içeren bir IDE (Integrated Development Environment - Bütünleşik Geliştirme Ortamı) gibi işlevlerinin ve özelliklerinin çoğunu Web arayüzü ile sunabilmektedir. 
- web2py ilk gününden beri çok kararlı bir yapıda olmuştur, bunun sebebi yukardan aşağı dizayn prensibini uygulamış olmasıdır; yani mesela API'sı yazılmaya başlamadan önce dikkatlice dizayn edilmiştir. Sürekli yeni işlevler eklenmesine rağmen, web2py hiçbir zaman geriye dönük uyumluluğunu kaybetmemiş ve bundan sonra gelecekte de, her nasıl bir yeni özellik veya işlev eklense de yine geriye dönük desteğini ve uyumluluğunu devam ettirecektir.     
- web2py, aşağıda OWASP``owasp``:cite 'ın da belirttiği üzere, diğer birçok çağdaş web uygulamasını etkileyen en önemli güvenlik meselelerini gerçekleşmeden önce ve tedarikli olarak ele alır.
- web2py hafiftir. Tüm toplam çekirdek (core) kütüphanelerinin, ki buna Veritabanı Soyutlaştırma Katmanı DAL, şablon dili ve tüm yardımcıları da dahildir, toplam boyutu 1.4MB ancak etmekte. Bunun yanında birkaç örnek uygulama ve resimleri de içeren web2py'ın standart dağıtım kaynak kodunun tümü ise toplam sadece 10.4MB. 
- web2py çok az sistem kaynağı kullanır ve gerçekten hızlıdır. Timothe Farrell tarafından geliştirilmiş olan Rocket``rocket``:cite  WSGI web sunucusunu kullanmakta. Bu sunucu mod_wsgi'li Apache sunucusu kadar hızlı olup, SSL ve IPv6'yı da desteklemektedir. 
- wep2py model, kontrolör ve görünümler için Python sözdizimini kullanmakta, ancak (Python'da yazılmış diğer web çatılarının aksine) model veya kontrolör kodlarını içe aktarmaz (import), sadece doğrudan çalıştırır. Bu, sunucunun (faal bir sistemde dahi) her defasında açıp kapatılmasına gerek kalmadan uygulamaların kurulup kaldırılması ve/ya değiştirilebilmesi ve farklı uygulamaların içerdikleri modüller birbirleriyle çakışmadan da beraber çalışabilmeleri anlamına gelmektedir. 
- web2py ORM (Nesne İlişkisel Eşleme, İng.Object Relational Mapping) yerine DAL kullanmaktadır. Kavramsal açıdan bu, farklı vt tablolarının farklı sınıflara değil, bir ``Table`` sınıfının farklı örneklemelerine (instance) eşleştirildiği , öte yandan da farklı vt kayıtlarının ilgili tablo sınıfının farklı örneklemelerinde değil de bir ``Row`` (satır) sınıfının farklı örneklemelerine eşleştirildiği anlamına gelmektedir. 
- Pratik açıdan, bu SQL sözdiziminin neredeyse birebir şekilde DAL sözdizimiyle eşleştiği ve birçok popüler ORM yazılımında olduğu gibi arka planda çalışan karmakarışık bir metasınıf (metaclass) programlamasının (ki bu da kodun ve dolayısıyla istemlere verilecek cevapların yavaşlaması demektir) bulunmadığı anlamına gelmektedir. 

WSGI ``wsgi-w``:cite ``wsgi-o``:cite (Web Server Gateway Interface), bir web sunucusuyla Python uygulamaları arasında iletişimi sağlamakla görevli, gittikçe yaygınlaşan bir Python standardıdır. 

Aşağıda web2py'ın ana **admin** (yönetici) arayüzünü görmektesiniz:

[[image @///image/en200.png center 480px]]

### Security
``security``:inxx
The Open Web Application Security Project``owasp``:cite  (OWASP) is a free and open worldwide community focused
on improving the security of application software.

OWASP has listed the top ten security issues that put web applications at risk.
That list is reproduced here, along with a description of how each issue is addressed by web2py:
- ``cross site scripting``:inxx  "Cross Site Scripting (XSS): XSS flaws occur whenever an application takes user supplied data and sends it to a web browser without first validating or encoding that content. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, possibly introduce worms, etc." ''web2py, by default, escapes all variables rendered in the view, preventing XSS.''
- ``injection flaws``:inxx "Injection Flaws: Injection flaws, particularly SQL injection, are common in web applications. Injection occurs when user-supplied data is sent to an interpreter as part of a command or query. The attacker's hostile data tricks the interpreter into executing unintended commands or changing data." ''web2py includes a Database Abstraction Layer that makes SQL injection impossible. Normally, SQL statements are not written by the developer.  Instead, SQL is generated dynamically by the DAL, ensuring that all inserted data is properly escaped.''
- ``malicious file execution``:inxx "Malicious File Execution: Code vulnerable to remote file inclusion (RFI) allows attackers to include hostile code and data, resulting in devastating attacks, such as total server compromise." ''web2py allows only exposed functions to be executed, preventing malicious file execution. Imported functions are never exposed; only actions are exposed. web2py uses a Web-based administration interface which makes it very easy to keep track of what is exposed and what is not.''
- ``insecure object reference``:inxx "Insecure Direct Object Reference: A direct object reference occurs when a developer exposes a reference to an internal implementation object, such as a file, directory, database record, or key, as a URL or form parameter. Attackers can manipulate those references to access other objects without authorization." ''web2py does not expose any internal objects; moreover, web2py validates all URLs, thus preventing directory traversal attacks. web2py also provides a simple mechanism to create forms that automatically validate all input values.''
- ``CSRF``:inxx "Cross Site Request Forgery (CSRF): A CSRF attack forces a logged-on victim's browser to send a pre-authenticated request to a vulnerable web application, which then forces the victim's browser to perform a hostile action to the benefit of the attacker. CSRF can be as powerful as the web application that it attacks." ''web2py prevents CSRF as well as accidental double submission of forms by assigning a one-time random token to each form. Moreover web2py uses UUID for session cookie.''
- ``information leakage``:inxx ``improper error handling``:inxx "Information Leakage and Improper Error Handling: Applications can unintentionally leak information about their configuration, internal workings, or violate privacy through a variety of application problems. Attackers use this weakness to steal sensitive data, or conduct more serious attacks." ''web2py includes a ticketing system. No error can result in code being exposed to the users. All errors are logged and a ticket is issued to the user that allows error tracking. But errors and source code are accessible only to the administrator.''
- "Broken Authentication and Session Management: Account credentials and session tokens are often not properly protected. Attackers compromise passwords, keys, or authentication tokens to assume other users' identities." ''web2py provides a built-in mechanism for administrator authentication, and it manages sessions independently for each application. The administrative interface also forces the use of secure session cookies when the client is not "localhost". For applications, it includes a powerful Role Based Access Control API.''
- ``cryptographic store``:inxx "Insecure Cryptographic Storage: Web applications rarely use cryptographic functions properly to protect data and credentials. Attackers use weakly protected data to conduct identity theft and other crimes, such as credit card fraud." ''web2py uses the MD5 or the HMAC+SHA-512 hash algorithms to protect stored passwords. Other algorithms are also available.''
- ``secure communications``:inxx "Insecure Communications: Applications frequently fail to encrypt network traffic when it is necessary to protect sensitive communications." ''web2py includes the SSL-enabled``ssl``:cite  Rocket WSGI server, but it can also use Apache or Lighttpd and mod_ssl to provide SSL encryption of communications.''
- ``access restriction``:inxx "Failure to Restrict URL Access: Frequently an application only protects sensitive functionality by preventing the display of links or URLs to unauthorized users. Attackers can use this weakness to access and perform unauthorized operations by accessing those URLs directly." ''web2py maps URL requests to Python modules and functions. web2py provides a mechanism for declaring which functions are public and which require authentication and authorization. The included Role Based Access Control API allow developers to restrict access to any function based on login, group membership or group based permissions. The permissions are very granular and can be combined with database filters to allow, for example, to give access to specific tables and/or records. web2py also allows digitally signed URL and provides API to digitally sign Ajax callbacks.''

web2py was reviewed for security and you can find the result of the review in ref.``pythonsecurity``:cite.

### In the box

You can download web2py from the official web site:

``
http://www.web2py.com
``:code

web2py is composed of the following components:
- **libraries**: provide core functionality of web2py and are accessible programmatically.
- **web server**: the Rocket WSGI web server.
- the **admin** application: used to create, design, and manage other web2py applications. **admin** provides a complete web-based Integrated Development Environment (IDE) for building web2py applications. It also includes other functionality, such as web-based testing and a web-based shell.
- the **examples** application: contains documentation and interactive examples. **examples** is a clone of the official web2py.com web site, and includes epydoc documentation.
- the **welcome** application: the basic scaffolding template for any other application. By default it includes a pure CSS cascading menu and user authentication (discussed in Chapter 9).

web2py is distributed in source code, and in binary form for Microsoft Windows and for Mac OS X.

The source code distribution can be used in any platform where Python runs and includes the above-mentioned components.
To run the source code, you need Python 2.5, 2.6 or 2.7 pre-installed on the system. You also need one of the supported database engines installed.
For testing and light-demand applications, you can use the SQLite database, included with Python 2.7.

The binary versions of web2py (for Windows and Mac OS X) include a Python 2.7 interpreter and
the SQLite database. Technically, these two are not components of web2py. Including them in the binary distributions
enables you to run web2py out of the box.

The following image depicts the overall web2py structure:

[[image @///image/en300.png center 480px]]

At the bottom we find the interpreter. Moving up we find the web server (rocket), the libraries, and the applications. Each application consists for its own MVC design (models, controllers, views, modules, languages, databases, and static files). Each application includes it own database administration code (appadmin). Every web2py instance ships with three applications: welcome (the scaffolding app), admin (the web based IDE), and examples (copy of website and examples). 

### About this book

This book includes the following chapters, besides this introduction:
- [[Chapter 2 ../02]] is a minimalist introduction to Python. It assumes knowledge of both procedural and object-oriented programming concepts such as loops, conditions, function calls and classes, and covers basic Python syntax. It also covers examples of Python modules that are used throughout the book. If you already know Python, you may skip Chapter 2.
- [[Chapter 3 ../03]] shows how to start web2py, discusses the administrative interface, and guides the reader through various examples of increasing complexity: an application that returns a string, a counter application, an image blog, and a full blown wiki application that allows image uploads and comments, provides authentication, authorization, web services and an RSS feed. While reading this chapter, you may need to refer to Chapter 2 for general Python syntax and to the following chapters for a more detailed reference about the functions that are used.
- [[Chapter 4 ../04]] covers more systematically the core structure and libraries: URL mapping, request, response, sessions, caching, scheduler, cron, internationalization and general workflow.
- [[Chapter 5 ../05]] is a reference for the template language used to build views. It shows how to embed Python code into HTML, and demonstrates the use of helpers (objects that can generate HTML).
- [[Chapter 6 ../06]] covers the Database Abstraction Layer, or DAL. The syntax of the DAL is presented through a series of examples.
- [[Chapter 7 ../07]] covers forms, form validation and form processing. FORM is the low level helper for form building. SQLFORM is the high level form builder. In Chapter 7 we also discuss Create/Read/Update/Delete (CRUD) API.
- [[Chapter 8 ../08]] covers communication features as retrieving and sending emails and SMSes.
- [[Chapter 9 ../09]] covers authentication, authorization and the extensible Role-Based Access Control mechanism available in web2py. Mail configuration and CAPTCHA are also discussed here, since they are used for authentication. In the third edition of the book we have added extensive coverage of integration with third-party authentication mechanisms such as OpenID, OAuth, Google, Facebook, LinkedIn, etc.
- [[Chapter 10 ../10]] is about creating web services in web2py. We provide examples of integration with the Google Web Toolkit via Pyjamas, and with Adobe Flash via PyAMF.
- [[Chapter 11 ../11]] is about web2py and jQuery recipes. web2py is designed mainly for server-side programming, but it includes jQuery, since we have found it to be the best open-source JavaScript library available for effects and Ajax. In this chapter, we discuss how to effectively use jQuery with web2py.
- [[Chapter 12 ../12]] discusses web2py components and plugins as a way to build modular applications. We provide an example of a plugin that implements many commonly used functionality, such as charting, comments, and tagging.
- [[Chapter 13 ../13]] is about production deployment of web2py applications. We specifically discuss the deployment on a LAMP web server (which we consider the main deployment alternative). We discuss alternative web servers, and configuration of the PostgreSQL database. We discuss running as a service on a Microsoft Windows environment, and deployment on some specific platforms including Google Applications Engine, Heroku, and PythonAnywhere. In this chapter, we also discuss security and scalability issues.
- [[Chapter 14 ../14]] contains a variety of other recipes to solve specific tasks, including upgrades, geocoding, pagination, the Twitter API, and more.
- [[Chapter 15 ../15]] has information and helping and contributing to the project, with topics such as making bug reports and contributing changes to the code.

This book only covers basic web2py functionalities and the API that ships with web2py.
This book does not cover web2py appliances (i.e. ready made applications).

You can download web2py appliances from the corresponding web site ``appliances``:cite.

You can find additional topics discussed on the usergroup``usergroup``:cite. There is also AlterEgo``alterego``:cite, the old web2py blog and FAQ.
``MARKMIN``:inxx
This book has been written using the MARKMIN syntax [[See Chapter 5 ../05#markmin_syntax]] and automatically converted to HTML, LaTeX and PDF.

### Support

The main support channel is the usergroup``usergroup``:cite, with dozens of posts every day. Even if you're a newbie, don't hesitate to ask - we'll be pleased to help you.  
There is also a formal issue tracker system on http://code.google.com/p/web2py/issues . Last but not least, you can have professional support (see the web site for details). 

### Contribute

Any help is really appreciated. You can help other users on the user group, or by directly submitting patches on the program (at the GitHub site https://github.com/web2py/web2py). 
Even if you find a typo on this book, or have an improvement on it, the best way to help is by patching the book itself (which is under the source folder of the repository 
at https://github.com/mdipierro/web2py-book).
For more information on contributing, please see [[Chapter 15 ..\15]]

[[web2py_style]]
### Elements of style

PEP8 ``style``:cite  contains good style practices when programming with Python. You will find
that web2py does not always follow these rules. This is not because of omissions or negligence; it is our
belief that the users of web2py should follow these rules and we encourage it. We chose not to
follow some of those rules when defining web2py helper objects in order to minimize the probability
of name conflict with objects defined by the user.

For example, the class that represents a ``<div>`` is called ``DIV``, while according to the
Python style reference it should have been called ``Div``. We believe that, for this specific example that
using an all-upper-case "DIV" is a more natural choice. Moreover, this approach leaves programmers
free to create a class called "Div" if they choose to do so.
Our syntax also maps naturally into the DOM notation of most browsers (including, for example, Firefox).

According to the Python style guide, all-upper-case strings should be used for constants and not
variables. Continuing with our example, even considering that ``DIV`` is a class,
it is a special class that should never be modified by
the user because doing so would break other web2py applications.
Hence, we believe this qualifies the ``DIV`` class as
something that should be treated as a constant, further justifying our choice of notation.

In summary, the following conventions are followed:
- HTML helpers and validators are all upper case for the reasons discussed above (for example ``DIV``, ``A``, ``FORM``, ``URL``).
- The translator object ``T`` is upper case despite the fact that it is an instance of a class and not a class itself. Logically the translator object performs an action similar to the HTML helpers, it affects rendering part of the presentation. Also, ``T`` needs to be easy to locate in the code and must have a short name.
- DAL classes follow the Python style guide (first letter capitalized), for example ``Table``, ``Field``, ``Query``, ``Row``, ``Rows``, etc.

In all other cases we believe we have followed, as much as possible,
the Python Style Guide (PEP8).
For example all instance objects are lower-case (request, response, session, cache), and all internal classes are capitalized.

In all the examples of this book, web2py keywords are shown in bold, while strings and comments are shown in italic.


### License
``license``:inxx

web2py is licensed under the LGPL version 3 License. The full text of the license is available in ref.``lgpl3``:cite.

In accordance with LGPL you may:

- redistribute web2py with your apps (including official web2py binary versions)
- release your applications which use official web2py libraries under any license you wish

Yet you must:

- make clear in the documentation that your application uses web2py
- release any modification of the web2py libraries under the LGPLv3 license

The license includes the usual disclaimer:

THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT
HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE,
BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER
PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

**Earlier versions**

Earlier versions of web2py, 1.0.*-1.90.*, were released under the GPL2 license plus a
commercial exception which, for practical purposes, was very similar to the current LGPLv3.

**Third party software distributed with web2py**

web2py contains third party software under the gluon/contrib/ folder and various JavaScript and CSS files.
These files are distributed with web2py under their original licenses, as stated in the files.


### Acknowledgments

web2py was originally developed by and copyrighted by Massimo Di Pierro.
The first version (1.0) was released in October, 2007. Since then it has been adopted by many users, some of whom have also contributed bug reports, testing, debugging, patches, and proofreading of this book.

Some of the major developers and contributors are, in alphabetical order by first name:

Adam Bryzak,
Adam Gojdas,
Adrian Klaver,
Alain Boulch,
Alan Etkin,
Alec Taylor,
Alexandre Andrade,
Alexey Nezhdanov,
Alvaro Justen,
Anand Vaidya,
Anatoly Belyakov,
Ander Arbelaiz,
Anders Roos,
Andrew Replogle,
Andrew Willimott,
Angelo Compagnucci,
Angelo and Villas,
Annet Vermeer,
Anthony Bastardi,
Anton Muecki,
Antonio Ramos,
Arun Rajeevan,
Attila Csipa,
Ben Goosman,
Ben Reinhart,
Benjamin,
Bernd Rothert,
Bill Ferret,
Blomqvist,
Boris Manojlovic,
Branko Vukelic,
Brent Zeiben,
Brian Cottingham,
Brian Harrison,
Brian Meredyk,
Bruno Rocha,
CJ Lazell,
Caleb Hattingh,
Carlos Galindo,
Carlos Hanson,
Carsten Haese,
Cedric Meyer,
Charles Law,
Charles Winebrinner,
Chris Clark,
Chris May,
Chris Sanders,
Christian Foster Howes,
Christopher Smiga,
Christopher Steel,
Clavin Sim,
Cliff Kachinske,
Corne Dickens,
Craig Younkins,
Dan McGee,
Dan Ragubba,
Dane Wright,
Danny Morgan,
Daniel Gonz,
Daniel Haag,
Daniel Lin,
Dave Stoll,
David Adley,
David Harrison,
David Lin,
David Marko,
David Wagner,
Denes Lengyel,
Diaz Luis,
Dirk Krause,
Dominic Koenig,
Doug Warren,
Douglas Philips,
Douglas Soares de Andrade,
Douglas and Alan,
Dustin Bensing,
Elcio Ferreira,
Eric Vicenti,
Erwin Olario,
Falko Krause,
Farsheed Ashouri,
Felipe Meirelles,
Flavien Scheurer,
Fran Boon,
Francisco Gama,
Fred Yanowski,
Friedrich Weber,
Gabriele Alberti,
Gergely Kontra,
Gergely Peli,
Gerley Kontra,
Gilson Filho,
Glenn Caltech,
Graham Dumpleton,
Gregory Benjamin,
Gustavo Di Pietro,
Gyuris Szabolcs,
Hamdy Abdel-Badeea,
Hans C. v. Stockhausen,
Hans Donner,
Hans Murx,
Huaiyu Wang,
Ian Reinhart Geiser,
Iceberg,
Igor Gassko,
Ismael Serratos,
Jan Beilicke,
Jay Kelkar,
Jeff Bauer,
Jesus Matrinez,
Jim Karsten,
Joachim Breitsprecher,
Joakim Eriksson,
Joe Barnhart,
Joel Carrier,
Joel Samuelsson,
John Heenan,
Jon Romero,
Jonas Rundberg,
Jonathan Benn,
Jonathan Lundell,
Jose Jachuf,
Joseph Piron,
Josh Goldfoot,
Josh Jaques,
Jose Vicente de Sousa,
Jurgis Pralgauskis,
Keith Yang,
Kenji Hosoda,
Kenneth Lundstr,
Kirill Spitsin,
Kyle Smith,
Larry Weinberg,
Limodou,
Loren McGinnis,
Louis DaPrato,
Luca De Alfaro,
Luca Zachetti,
Lucas D'Avila,
Madhukar R Pai,
Manuele Presenti,
Marc Abramowitz,
Marcel Hellkamp,
Marcel Leuthi,
Marcello Della Longa,
Margaret Greaney,
Maria Mitica,
Mariano Reingart,
Marin Prajic,
Marin Pranji,
Marius van Niekerk,
Mark Kirkwood,
Mark Larsen,
Mark Moore,
Markus Gritsch,
Mart Senecal,
Martin Hufsky,
Martin Mulone,
Martin Weissenboeck,
Mateusz Banach,
Mathew Grabau,
Mathieu Clabaut,
Matt Doiron,
Matthew Norris,
Michael Fig,
Michael Herman,
Michael Howden,
Michael Jursa,
Michael Toomim,
Michael Willis,
Michele Comitini,
Miguel Goncalves,
Miguel Lopez,
Mike Amy,
Mike Dickun,
Mike Ellis,
Mike Pechkin,
Milan Melena,
Muhammet Aydin,
Napoleon Moreno,
Nathan Freeze,
Niall Sweeny,
Niccolo Polo,
Nick Groenke,
Nick Vargish,
Nico de Groot,
Nico Zanferrari,
Nicolas Bruxer,
Nik Klever,
Olaf Ferger,
Oliver Dain,
Olivier Roch Vilato,
Omi Chiba,
Ondrej Such,
Ont Rif,
Oscar Benjamin,
Osman Masood,
Ovidio Marinho Falcao Neto,
Pai,
Panos Jee,
Paolo Betti,
Paolo Caruccio,
Paolo Gasparello,
Paolo Valleri,
Patrick Breitenbach,
Pearu Peterson,
Peli Gergely,
Pete Hunt,
Peter Kirchner,
Phyo Arkar Lwin,
Pierre Thibault,
Pieter Muller,
Piotr Banasziewicz,
Ramjee Ganti,
Richard Gordon,
Richard Ree,
Robert Kooij,
Robert Valentak,
Roberto	Perdomo,
Robin Bhattacharyya,
Roman Bataev,
Ron McOuat,
Ross Peoples,
Ruijun Luo,
Running Calm,
Ryan Seto,
Salomon Derossi,
Sam Sheftel,
Scott Roberts,
Sebastian Ortiz,
Sergey Podlesnyi,
Sharriff Aina,
Simone Bizzotto,
Sriram Durbha,
Sterling Hankins,
Stuart Rackham,
Telman Yusupov,
Thadeus Burgess,
Thomas Dallagnese,
Tim Farrell,
Tim Michelsen,
Tim Richardson,
Timothy Farrell,
Tito Garrido,
Tyrone Hattingh,
Vasile Ermicioi,
Vidul Nikolaev Petrov,
Vidul Petrov,
Vinicius Assef,
Vladimir Donnikov,
Vladyslav Kozlovsky,
Vladyslav Kozlovskyy,
Wang Huaiyu,
Wen Gong,
Wes James,
Will Stevens,
Yair Eshel,
Yarko Tymciurak,
Yoshiyuki Nakamura,
Younghyun Jo,
Zahariash.

I am sure I forgot somebody, so I apologize.

I particularly thank Anthony, Jonathan, Mariano, Bruno, Vladyslav, Martin, Nathan, Simone, Thadeus, Tim, Iceberg, Denes, Hans, Christian, Fran and Patrick for their major contributions to web2py and Anthony, Alvaro, Brian, Bruno, Denes, Dane Denny, Erwin, Felipe, Graham, Jonathan, Hans, Kyle, Mark, Margaret, Michele, Nico, Richard, Roberto, Robin, Roman, Scott, Shane, Sharriff, Sriram, Sterling, Stuart, Thadeus, Wen (and others) for proofreading various versions of this book. Their contribution was invaluable. If you find any errors in this book, they are exclusively my fault, probably introduced by a last-minute edit. I also thank Ryan Steffen of Wiley Custom Learning Solutions for help with publishing the first edition of this book.

web2py contains code from the following authors, whom I would like to thank:

Guido van Rossum for Python``python``:cite, Peter Hunt, Richard Gordon, Timothy Farrell for the Rocket``rocket``:cite  web server, Christopher Dolivet for EditArea``editarea``:cite, Bob Ippolito for simplejson``simplejson``:cite, Simon Cusack and Grant Edwards for pyRTF``pyrtf``:cite, Dalke Scientific Software for pyRSS2Gen``pyrss2gen``:cite, Mark Pilgrim for feedparser``feedparser``:cite, Trent Mick for markdown2``markdown2``:cite, Allan Saddi for fcgi.py, Evan Martin for the Python memcache module``memcache``:cite, John Resig for jQuery``jquery``:cite.

I thank Helmut Epp (provost of DePaul University), David Miller (Dean of the College of Computing and Digital Media of DePaul University), and Estia Eichten (Member of MetaCryption LLC), for their continuous trust and support.

Finally, I wish to thank my wife, Claudia, and my son, Marco, for putting up with me during the many hours I have spent developing web2py, exchanging emails with users and collaborators, and writing this book. This book is dedicated to them.

